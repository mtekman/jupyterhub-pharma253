<html>
<!-- {% extends "templates/spawn.html" %} -->
<!-- {% block main %} -->

<!-- {{ super() }} -->
<style>
  thead { font-family: monospace; font-style: italic; }
  form { display:grid; }
  #curr_resource { position:absolute; bottom: 20px; right: 20px}
  #usage_cont { border: solid black; border-radius: 20px;
  text-align: center; background-color: #cdc;
  box-shadow: 5px 5px 5px #888;}
  #chart {position: absolute; top: 50px; left: 50px; width: 200px; height: 200px;}
  table { border-spacing: 5px;  border-collapse: separate;
  text-align:center;  margin-left: auto; margin-right: auto}
  td,th { padding-left: 30px; }
  #profile_cont { font-size: large; flex-direction: row; display:flex;
  width: 90%; margin-left: auto; margin-right: auto}
  #profile_cont select { box-shadow: 2px 2px 2px #888; flex-grow: 2;
  margin-bottom: 5px;}
  #profile_cont span { flex-grow: 4; }
  #prealloc_message {margin-left:auto; margin-right:auto;
  margin-top:6px; font-size:small;}
  th { text-align:center; }
  td input[type="number"] { margin-top: 10px; text-align:center;
  border-radius: 10px;
  border: 2px solid #555; width: 120px;}
  td input[type="range"] {width: 150px;}
</style>

<!-- Load d3.js -->
    <script src="d3.v7.min.js"></script>

<!-- Create a div where the graph will take place -->
    <div id="my_dataviz"></div>

<div id="highlighted_user"></div>

<div>
    <select id="active_users" label="Show Users" multiple="true" onchange="renderData2()">
  </select>
</div>

<!-- {% endblock %} -->

<!-- {% block script %} -->

<script>

function generateFakeMetrics(){
    const rand_frac = 1.5 + (Math.random() * 1.5)
    const total_cpu_all = Math.random() * 100
    const total_cpu_jpy = (total_cpu_all / rand_frac)  + (Math.random() * total_cpu_all / rand_frac);
    const total_mem_all = Math.random() * 5000
    const total_mem_jpy = (total_mem_all / rand_frac)  + (Math.random() * total_mem_all/ rand_frac);

    var red = {
        "time" : {
            "cached": Date(), "now" : Date.now(), "update_interval" : 2,
            "next_update" : 2, "last_update" : 8.6
        },
        "system" : {
            "ram_free_gb" : 119,  "ram_used_gb" : 2.8, "ram_total_gb" : 202.3,
            "ram_usage_percent" : 2.3, "cpu_usage_percent" : 2.1, "cpu_count" : 36
        },
        "user" : {
            "cpu_percent" : {
                "all_processes": total_cpu_all, "all_jupyter_users": total_cpu_jpy
            },
            "memory_rss_mb": {
                "all_jupyter_users": total_mem_jpy, "all_processes": total_mem_all
            }
        }
    }

    var remaining_mem = total_mem_jpy
    var remaining_cpu = total_cpu_jpy

    var user_count = 0
    while ((remaining_mem > 0) && (remaining_cpu > 0))
    {
        let username = "user" + user_count

        red["user"]["cpu_percent"][username] = 1 + Math.random() * remaining_cpu
        red["user"]["memory_rss_mb"][username] = 1 + Math.random() * remaining_mem

        remaining_cpu -= red["user"]["cpu_percent"][username]
        remaining_mem -= red["user"]["memory_rss_mb"][username]

        user_count += 1
    }
    return(red)
}

// set the dimensions and margins of the graph
const margin = {top: 10, right: 30, bottom: 30, left: 60},
      width = 460 - margin.left - margin.right,
      height = 400 - margin.top - margin.bottom;

// append the svg object to the body of the page
const svg = d3.select("#my_dataviz")
      .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

// Update the lines
const stroke_width_user = 2
const stroke_width_user_highlight = 6

var style_map = new Map()
style_map.set("all_processes", {"color" : '#e41a1c', "width" : 5 })
style_map.set("all_jupyter_users", {"color" : '#377eb8', "width" : 4})

function getRandomColor() {
  var letters = '0123456789ABCDEF';
  var color = '#';
  for (var i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }
  return color;
}

function startTimer(do_func, millisecs) {
    var timer
    obj = {};
    obj.resume = function() {
        timer = setInterval(do_func, millisecs);
    };
    obj.pause = function() {
        clearInterval(timer);
    };
    obj.resume();
    return obj;
}



const max_points = 20
const bin_size = 5
// Needs to be a map of User values, with entries updated with timestamps
// {"User1" : [{ "time": 123455, "cpu_percent" : 1.3 }, ... ]
// Map.get("User1").push({ new_vals })
var timescale_data = new Map()


function pullMetrics(){
    // Data are the metrics
    const metrics = generateFakeMetrics()
    const time = metrics.time.now

    for (username in metrics.user.cpu_percent){
        const packet = { "time" : time,
                         "cpu_percent" : metrics.user.cpu_percent[username],
                         "memory_rss_mb" : metrics.user.memory_rss_mb[username]}

        if (timescale_data.has(username)){
            timescale_data.get(username).push(packet)
        } else {
            timescale_data.set(username, [packet])
            // Add as dropdown option in filter box
            let opt = document.createElement("option")
            opt.value = username
            opt.innerText = username
            opt.selected = true
            document.getElementById("active_users").appendChild(opt)
            // Add unique colouring
            style_map.set(username, { "color" : getRandomColor(),
                                      "width" : 2 })
        }
    }
}

var hist_data = new Map()
hist_data.set("all_processes", [])

function mergeHistory(last_secs = 10){
    //Historical data gets merged into a single average, every n ticks
    let ref_array = timescale_data.get("all_processes")
    var min_time = Date.now() - (last_secs*1000)
    //if (ref_array.filter(x => x.time < min_time).length > 20){

        for (const [user, arrays] of timescale_data)
        {
            let data_before = arrays.filter(x => x.time < min_time)
            let len_data = data_before.length
            let data_summed = data_before
                .reduce((acc, obj) => {
                    acc.cpu_percent += obj.cpu_percent || 0;
                    acc.memory_rss_mb += obj.memory_rss_mb || 0;
                    return acc;
                }, {cpu_percent: 0, memory_rss_mb: 0})

            let data_avg = {
                "time" : min_time,
                "cpu_percent" : (data_summed.cpu_percent / len_data) || 0,
                "memory_rss_mb" : (data_summed.memory_rss_mb / len_data) || 0
            }

            if (hist_data.has(user)){
                hist_data.get(user).push(data_avg)
            } else {
                hist_data.set(user, [data_avg])
            }

            // Shorten all histories, but use last value of hist as starting point
            //timescale_data.set(user, [data_avg].concat(arrays.filter(x => x.time >= min_time)))
            timescale_data.set(user, arrays.filter(x => x.time >= min_time))
        }
    //}
}

function plotDataHistorical(new_style_map, x, y){
    // Plot historical data
    let old_lines = svg.selectAll("path.old")
    old_lines = old_lines
        .data(hist_data, (d,i) => d)
        .join(
            enter => enter
                .append("path")
                .attr("class", "old")
                .attr("fill", "none")
                .attr("stroke", d => new_style_map.get(d[0]).color)
                .attr("stroke-width", d => new_style_map.get(d[0]).width)
                .attr("d", function(d){
                    return d3.line()
                        .x(d => x(d.time))
                        .y(d => y(d.cpu_percent))
                        .curve(d3.curveBasis)(d[1])
                }),
            update => update,
            exit => exit.call(old_lines => old_lines.transition().duration(0).remove())
        )
        .call(old_lines => old_lines.transition().duration(0)
              .attr("fill", "none")
              .attr("stroke", d => new_style_map.get(d[0]).color )
              .attr("stroke-width", d => new_style_map.get(d[0]).width)
              .attr("d", function(d){
                  return d3.line()
                      .x(d => x(d.time))
                      .y(d => y(d.cpu_percent))
                      .curve(d3.curveBasis)(d[1])
              }))
}


function plotDataNew(new_style_map, x, y){
    // Plot the current data
    let new_lines = svg.selectAll("path.new")
    new_lines = new_lines
        .data(timescale_data, (d,i) => d)
        .join(
            enter => enter
                .append("path")
                .attr("class", "new")
                .attr("fill", "none")
                .attr("stroke", d => new_style_map.get(d[0]).color )
                .attr("stroke-width", d => new_style_map.get(d[0]).width)
                .attr("d", function(d){
                    return d3.line()
                        .x(d => x(d.time))
                        .y(d => y(d.cpu_percent))
                        .curve(d3.curveBasis)(d[1])
                })
                .on("mouseover", function(ev){
                    let path = ev.target
                    let pathname = path.__data__[0]
                    document.getElementById("highlighted_user").innerText = pathname
                    path.style.strokeWidth = stroke_width_user_highlight
                    timer_plot.pause()
                })
                .on("mouseout", function(ev){
                    let path = ev.target
                    let pathname = path.__data__[0]

                    path.style.strokeWidth = new_style_map.get(pathname).width

                    document.getElementById("highlighted_user").innerText = null
                    timer_plot.resume()
                })

            ,
            update => update,
            exit => exit.call(new_lines => new_lines.transition().duration(100).remove())
        )
        .call(new_lines => new_lines.transition().duration(100)
              .attr("fill", "none")
              .attr("stroke", d => new_style_map.get(d[0]).color )
              .attr("stroke-width", d => new_style_map.get(d[0]).width)
              .attr("d", function(d){
                    return d3.line()
                        .x(d => x(d.time))
                        .y(d => y(d.cpu_percent))
                        .curve(d3.curveBasis)(d[1])
              }))

}


function renderData2(){
    const points_max = 20 // show this many values at any given time
    const points_actual = 5  // the first N points are true, the rest are subsampled.

    // For max points, the first
    const hide_users = Array.from(document.getElementById("active_users").options)
        .filter(x => x.selected == false).map(x => x.value)

    var new_style_map = new Map(style_map)
    if (hide_users.length > 0){
        hide_users.forEach(user => {
            new_style_map.set(user, { "color" : "#aaaaaa", "width" : 0.5 })
        })
    }

    //var filtered_data = new Map(timescale_data)
    //filtered_data = smoothAndSubSample(timescale_data)
    const ref_hist = hist_data.get("all_processes")
    const ref_new = timescale_data.get("all_processes")

    const len_hist = ref_hist.length * 2
    const len_new = width / 2

    let timenow = new Date()

    // Update the axis ranges
    const xold = d3.scaleLinear()
          .domain(d3.extent(ref_hist, d => d.time))
          .range([ 0, len_hist ])

    const xnew = d3.scaleLinear()
          .domain([timenow - 10000, timenow])
          .range([ len_hist, width ])

    const y = d3.scaleLinear()
          .domain([0, d3.max(
              // Y-axis also takes historical data into account
              ref_hist.concat(ref_new),
              d => d.cpu_percent)
                  ]).range([ height, 0 ]);


    plotDataHistorical(new_style_map, xold, y)
    plotDataNew(new_style_map, xnew, y)

    // Initialize axes if not present
    let xnew_dom = document.getElementById("xaxis-new"),
        xold_dom = document.getElementById("xaxis-old"),
        yaxis_dom = document.getElementById("yaxis")

    if (xnew_dom != null){
        xnew_dom.remove()
        xold_dom.remove()
        yaxis_dom.remove()
    }

    // xnew
    svg.append("g").attr("id", "xaxis-new")
        .attr("transform", `translate(0, ${height})`)
        .call(d3.axisBottom(xnew).ticks(5).tickFormat(function(d){
            let dtime = new Date(d)
            return(dtime.getHours() + ":"  + dtime.getMinutes() + ":" + dtime.getSeconds())
        }))
    // xold
    svg.append("g").attr("id", "xaxis-old")
        .attr("transform", `translate(0, ${height})`)
        .call(d3.axisBottom(xold).ticks(5).tickFormat(function(d){
            let dtime = new Date(d)
            return(dtime.getHours() + ":"  + dtime.getMinutes() + ":" + dtime.getSeconds())
        }))

    svg.append("g").attr("id", "yaxis").call(d3.axisLeft(y).ticks(5))

}

var timer_metric = startTimer(pullMetrics, 1000)
var timer_plot = startTimer(renderData2, 1000)
var history_plot = startTimer(function(){mergeHistory(5)}, 5000)


pullMetrics()
pullMetrics()
pullMetrics()
renderData2()




</script>

<!-- {{ super() }} -->
<!-- {% endblock %} -->

</html>