<html>
<!-- {% extends "templates/spawn.html" %} -->
<!-- {% block main %} -->

<!-- {{ super() }} -->
<style>
  thead { font-family: monospace; font-style: italic; }
  form { display:grid; }
  #curr_resource { position:absolute; bottom: 20px; right: 20px}
  #usage_cont { border: solid black; border-radius: 20px;
  text-align: center; background-color: #cdc;
  box-shadow: 5px 5px 5px #888;}
  #chart {position: absolute; top: 50px; left: 50px; width: 200px; height: 200px;}
  table { border-spacing: 5px;  border-collapse: separate;
  text-align:center;  margin-left: auto; margin-right: auto}
  td,th { padding-left: 30px; }
  #profile_cont { font-size: large; flex-direction: row; display:flex;
  width: 90%; margin-left: auto; margin-right: auto}
  #profile_cont select { box-shadow: 2px 2px 2px #888; flex-grow: 2;
  margin-bottom: 5px;}
  #profile_cont span { flex-grow: 4; }
  #prealloc_message {margin-left:auto; margin-right:auto;
  margin-top:6px; font-size:small;}
  th { text-align:center; }
  td input[type="number"] { margin-top: 10px; text-align:center;
  border-radius: 10px;
  border: 2px solid #555; width: 120px;}
  td input[type="range"] {width: 150px;}
  #active_users {
      position: absolute; top: 0px; left: 0px
  }
  .xaxis .tick text {
      text-anchor : end;
      transform: translateY(5px) rotate(-90deg);
  }

</style>

<!-- Load d3.js -->
    <script src="d3.v7.min.js"></script>

<!-- Create a div where the graph will take place -->
    <div id="my_dataviz"></div>

<div id="highlighted_user"></div>

<div>
    <select id="active_users" label="Show Users" multiple="true" onchange="doPlot()">
  </select>
</div>

<!-- {% endblock %} -->

<!-- {% block script %} -->

<script>

function generateFakeMetrics(){
    const rand_frac = 1.5 + (Math.random() * 1.5)
    const total_cpu_all = Math.random() * 100
    const total_cpu_jpy = (total_cpu_all / rand_frac)  + (Math.random() * total_cpu_all / rand_frac);
    const total_mem_all = Math.random() * 5000
    const total_mem_jpy = (total_mem_all / rand_frac)  + (Math.random() * total_mem_all/ rand_frac);

    var red = {
        "time" : {
            "cached": Date(), "now" : Date.now(), "update_interval" : 2,
            "next_update" : 2, "last_update" : 8.6
        },
        "system" : {
            "ram_free_gb" : 119,  "ram_used_gb" : 2.8, "ram_total_gb" : 202.3,
            "ram_usage_percent" : 2.3, "cpu_usage_percent" : 2.1, "cpu_count" : 36
        },
        "user" : {
            "cpu_percent" : {
                "all_processes": total_cpu_all, "all_jupyter_users": total_cpu_jpy
            },
            "memory_rss_mb": {
                "all_jupyter_users": total_mem_jpy, "all_processes": total_mem_all
            }
        }
    }

    var remaining_mem = total_mem_jpy
    var remaining_cpu = total_cpu_jpy

    var user_count = 0
    while ((remaining_mem > 0) && (remaining_cpu > 0))
    {
        let username = "user" + user_count

        red["user"]["cpu_percent"][username] = 1 + Math.random() * remaining_cpu
        red["user"]["memory_rss_mb"][username] = 1 + Math.random() * remaining_mem

        remaining_cpu -= red["user"]["cpu_percent"][username]
        remaining_mem -= red["user"]["memory_rss_mb"][username]

        user_count += 1
    }
    return(red)
}

// set the dimensions and margins of the graph
const margin = {top: 10, right: 30, bottom: 30, left: 60},
      width = 460 - margin.left - margin.right,
      height = 400 - margin.top - margin.bottom;

// append the svg object to the body of the page
const svg = d3.select("#my_dataviz")
      .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

// Update the lines
const stroke_width_user = 2
const stroke_width_user_highlight = 6

var style_map = new Map()
style_map.set("all_processes", {"color" : '#e41a1c', "width" : 5 })
style_map.set("all_jupyter_users", {"color" : '#377eb8', "width" : 4})

function getRandomColor() {
  var letters = '0123456789ABCDEF';
  var color = '#';
  for (var i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }
  return color;
}

function startTimer(do_func, millisecs) {
    var timer
    obj = {};
    obj.resume = function() {
        timer = setInterval(do_func, millisecs);
    };
    obj.pause = function() {
        clearInterval(timer);
    };
    obj.resume();
    return obj;
}



const max_points = 20
const bin_size = 5
// Needs to be a map of User values, with entries updated with timestamps
// {"User1" : [{ "time": 123455, "cpu_percent" : 1.3 }, ... ]
// Map.get("User1").push({ new_vals })
var timescale_data = new Map()


function pullMetrics(){
    // Data are the metrics
    const metrics = generateFakeMetrics()
    const time = metrics.time.now

    for (username in metrics.user.cpu_percent){
        const packet = { "time" : time,
                         "cpu_percent" : metrics.user.cpu_percent[username],
                         "memory_rss_mb" : metrics.user.memory_rss_mb[username]}

        if (timescale_data.has(username)){
            timescale_data.get(username).push(packet)
        } else {
            timescale_data.set(username, [packet])
            // Add as dropdown option in filter box
            let opt = document.createElement("option")
            opt.value = username
            opt.innerText = username
            opt.selected = true
            document.getElementById("active_users").appendChild(opt)
            // Add unique colouring
            if (!(style_map.has(username))){
                style_map.set(username, { "color" : getRandomColor(),
                                          "width" : 2 })
            }
        }
    }
}

var hist_data = new Map()
hist_data.set("all_processes", [])

function squashDataOlderThan(last_ms = 1000){
    //Historical data gets merged into a single average, every n ticks
    let ref_array = timescale_data.get("all_processes")
    var min_time = Date.now() - (last_ms)
    //if (ref_array.filter(x => x.time < min_time).length > 20){

        for (const [user, arrays] of timescale_data)
        {
            let data_before = arrays.filter(x => x.time < min_time)
            let len_data = data_before.length
            let data_summed = data_before
                .reduce((acc, obj) => {
                    acc.cpu_percent += obj.cpu_percent || 0;
                    acc.memory_rss_mb += obj.memory_rss_mb || 0;
                    return acc;
                }, {cpu_percent: 0, memory_rss_mb: 0})

            let data_avg = {
                "time" : min_time,
                "cpu_percent" : (data_summed.cpu_percent / len_data) || 0,
                "memory_rss_mb" : (data_summed.memory_rss_mb / len_data) || 0
            }

            if (hist_data.has(user)){
                hist_data.get(user).push(data_avg)
            } else {
                hist_data.set(user, [data_avg])
            }

            // Shorten all histories, but use last value of hist as starting point
            //timescale_data.set(user, [data_avg].concat(arrays.filter(x => x.time >= min_time)))
            timescale_data.set(user, arrays.filter(x => x.time >= min_time))
        }
    //}
}

  function calculateDpoints(d,x,y){
      return d3.line()
          .x(d => x(d.time))
          .y(d => y(d.cpu_percent))
          .curve(d3.curveBasis)(d[1])
  }
   
function plotDataTo(classname, data, new_style_map, x, y){
    // Plot the current data
    let lines = svg.selectAll("path." + classname)
    lines = lines
        .data(data, function(grp_arr, ind, whole){
            return(ind)
        })
        .join(enter => enter
              .append("path")
              .attr("class", classname)
              .attr("fill", "none")
              .attr("stroke", d => new_style_map.get(d[0]).color )
              .attr("stroke-width", d => new_style_map.get(d[0]).width)
              .attr("d", d => calculateDpoints(d,x,y))
              .on("mouseover", function(ev){
                  let path = ev.target
                  let pathname = path.__data__[0]
                  document.getElementById("highlighted_user").innerText = pathname
                  path.style.strokeWidth = stroke_width_user_highlight
                  timer_plot.pause()
              })
              .on("mouseout", function(ev){
                  let path = ev.target
                  let pathname = path.__data__[0]                  
                  path.style.strokeWidth = new_style_map.get(pathname).width                  
                  document.getElementById("highlighted_user").innerText = null
                  timer_plot.resume()
              }),
              update => update,
              function(exit){
                  //console.log("exit", exit)
                  return(exit.call(lines => lines.remove().attr("d" ,"") ))
              })
        .call(lines => lines.transition().duration(trans_time)
              .attr("fill", "none")
              .attr("stroke", d => new_style_map.get(d[0]).color )
              .attr("stroke-width", d => new_style_map.get(d[0]).width)
              .attr("d", d => calculateDpoints(d,x,y)))

}

var fetch_every = 500,
    plot_every = 500,
    trans_time = 250,
    squash_every = 5000,
    hist_space = 10

  
  
  
function formatDate(d){
    let now = new Date(d)
    let hours = String(now.getHours()).padStart(2, '0');
    let minutes = String(now.getMinutes()).padStart(2, '0');
    let seconds = String(now.getSeconds()).padStart(2, '0');
    //return(`${hours}:${minutes}:${seconds}`);
    return(`${minutes}:${seconds}`);
}

  
function doPlot(){
    const points_max = 20 // show this many values at any given time
    const points_actual = 5  // the first N points are true, the rest are subsampled.

    // For max points, the first
    const hide_users = Array.from(document.getElementById("active_users").options)
        .filter(x => x.selected == false).map(x => x.value)

    var new_style_map = new Map(style_map)
    if (hide_users.length > 0){
        hide_users.forEach(user => {
            new_style_map.set(user, { "color" : "#aaaaaa", "width" : 0.5 })
        })
    }

    //var filtered_data = new Map(timescale_data)
    //filtered_data = smoothAndSubSample(timescale_data)
    const ref_hist = hist_data.get("all_processes")
    const ref_new = timescale_data.get("all_processes")

    let timenow = new Date()
    
    var len_hist = ref_hist.length * hist_space
    if (len_hist > width){
        len_hist = width
    }

    // Free space divided by letter spacing
    var how_many_new_to_plot = Math.floor((width - len_hist) / hist_space)

    var filtered_data = new Map()
    for (var [user, arrays] of timescale_data)
    {
        var last_hist = []
        if (hist_data.has(user)){
            last_hist = hist_data.get(user).slice(-1) || []
        }
        filtered_data.set(user, last_hist.concat(arrays.slice(-how_many_new_to_plot)))
    }

    // Update the axis ranges
    const xold = d3.scaleLinear()
          .domain(d3.extent(ref_hist, d => d.time))
          .range([ 0, len_hist])

    const xnew = d3.scaleLinear()
          .domain(d3.extent(filtered_data.get("all_processes"), d => d.time))
          .range([ len_hist, width ])

    const y = d3.scaleLinear()
          .domain([0, d3.max(
              // Y-axis also takes historical data into account
              ref_hist.concat(ref_new),
              d => d.cpu_percent)
                  ]).range([ height, 0 ]);


    plotDataTo("old", hist_data, new_style_map, xold, y)
    if (how_many_new_to_plot > 0){
        plotDataTo("new", filtered_data, new_style_map, xnew, y)
    }

    // Initialize axes if not present
    let xnew_dom = document.getElementById("xaxis-new"),
        xold_dom = document.getElementById("xaxis-old"),
        yaxis_dom = document.getElementById("yaxis")

    if (xnew_dom != null){
        xnew_dom.remove()
        xold_dom.remove()
        yaxis_dom.remove()
    }

    // xnew
    svg.append("g").attr("id", "xaxis-new")
        .attr("class", "xaxis")
        .attr("transform", `translate(0, ${height})`)
        .call(d3.axisBottom(xnew).ticks(5).tickFormat(formatDate))
    // xold
    svg.append("g").attr("id", "xaxis-old")
        .attr("class", "xaxis")
        .attr("transform", `translate(0, ${height})`)
        .call(d3.axisBottom(xold).ticks(Math.floor(len_hist/hist_space)+1).tickFormat(formatDate))

    svg.append("g").attr("id", "yaxis").call(d3.axisLeft(y).ticks(5))
}

var timer_metric = startTimer(pullMetrics, fetch_every)
var timer_plot = startTimer(doPlot, plot_every)
var history_plot = startTimer(function(){squashDataOlderThan(squash_every)}, squash_every)

pullMetrics()
doPlot()




</script>

<!-- {{ super() }} -->
<!-- {% endblock %} -->

</html>